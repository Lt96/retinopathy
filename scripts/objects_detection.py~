# -*- coding: utf-8 -*-

import numpy as np
from scipy import ndimage as ndi
import skimage
import skimage.morphology, skimage.filters, skimage.feature, \
    skimage.segmentation
import mahotas as mh
from numba import jit
# my libraries that deal with images and this data set specifically:
from imhandle import load_image, save_image, show_image, rmse, \
    load_set, rgb_to_grayscale, pxl_distr
from retina_im_lib import crop_black_border, expand, bfs_clustered, \
    erase_clusters


def exclude_backgr(gb):
    # CLAHE
    cl1 = skimage.exposure.equalize_adapthist(gb)
    cl1 = (cl1 * 256).astype(np.uint8)
    
    # Average filter
    aver = cl1 - mh.mean_filter(cl1, Bc=np.ones((12, 12)))
    #aver[aver < 0] = 0
    aver = np.abs(aver)
    aver = aver.astype(np.uint8)
    
    # CLAHE
    cl2 = skimage.exposure.equalize_adapthist(aver)
    
    return cl2


def detect_vessels_1(gb):
    # Excluding background
    gb2 = exclude_backgr(gb)
    # There is a lot of small noise and details; denoising
    gb3 = mh.gaussian_filter(gb2, sigma=1.0)

    # Computing response of Gabor filter (real part) at different angles
    resp = []
    for theta in np.linspace(0.0, 17.0 / 18.0 * np.pi, num=10):
        kernel = skimage.filters.gabor_kernel(frequency=0.4, theta=theta, 
                                              sigma_x=1.0 * 1.5, sigma_y=(1.0 / 1.75) * 1.5,
                                              n_stds=15)
        #resp.append(power(img, kernel))    # equivalent to Gaussian (cos^2 + sin^2 = 1)
        resp.append(ndi.convolve(gb3, np.real(kernel), mode='wrap'))

    response = np.max(resp, axis=0)
    response[response < 0] = 0
    #show_image(response)

    # freq=0.3, bandwidth=1.0, n_stds=15
    # freq=0.05, sigma_x=2.0, sigma_y=6.0, n_stds=15
    # 0.6, 2.0, 3.5, 15
    # 0.25, 1.0*2.0, (1.0 / 1.75) * 2.0, 15
    # 0.4, 1.0*1.5, (1.0 / 1.75) * 1.5, 15  - ok! except small line segments 
    #                                        (but there are some lines there in the image)
    
    # Histogram equalization
    response *= 1.0 / response.max()
    resp2 = skimage.exposure.equalize_adapthist(response)
    #show_image(resp2)
    resp2 = (resp2 * 256).astype('uint8')
    
    # Removing noise
    noise_level = np.percentile(resp2[resp2 != 0], 80)
    resp3 = np.where(resp2 > noise_level, resp2, 0)
    #show_image(resp3, fig_size=(12, 12))
    
    # Removing small objects
    mask_large = skimage.morphology.remove_small_objects(resp3 != 0, min_size=30, connectivity=2)
    #pxl_distr(mask_large)
    resp4 = np.where(mask_large, resp3, 0)
    
    return resp4


def objects_map(gb):
    bfs = bfs_clustered(gb, radius=7, tol=5)
    bfs2 = erase_clusters(bfs, small_tol=20, large_tol=500, small_replace=0)
    return bfs2


def exudate_detect_1(gb):
    mask = objects_map(gb)
    result = np.where(mask, gb, 0.0)
    ans2 = skimage.morphology.remove_small_objects(result != 0, min_size=20, connectivity=2)
    return ans2


def optic_disc_fit(folder, n_pca_compns=6, box_shape=30):
    # All images that are to be used for PCA fitting must be put in special 
    # folder (`folder`).
    cl_boxes_all = get_clusters_from_img_set(folder)
    pca = sklearn.decomposition.PCA(n_components=n_pca_compns)
    #boxes_pca = pca.fit_transform(cl_boxes_all)
    pca.fit(cl_boxes_all)
    return pca


def optic_disc_detect(gb, pca, box_shape=30):
    # box_shape must correspond to box_shape used to fit PCA
    box_shape = 30
    boxes, cl_no = get_clusters(cl2, box_shape)
    cl_num = cl1.max() + 1
    rec = pca.inverse_transform(pca.transform(boxes))
    pca_error = np.linalg.norm(boxes - rec, axis=1)
    thr = np.percentile(pca_error, 50)
    cl_no = np.array(cl_no)
    cl_to_leave = cl_no[pca_error < thr]
    if 0 not in cl_to_leave:
        cl_to_leave = np.hstack((0, cl_to_leave))
    cl3 = leave_segments(cl2, cl_to_leave)
    return cl3
